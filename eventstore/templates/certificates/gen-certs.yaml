# Generate esdb certs for nodes
# Init container generates certificates using es-gencert-cli image
# Actual container patches the esdb-certs secret
  
#DNS names for certificate
{{- $dnsNames := list}}
{{- range $i, $e := until ($.Values.deployment.clusterSize | int) }}
  {{- $dnsNames = append $dnsNames (print "DNS:" (index $.Values.deployment.hosts ($i | toString))) }}
{{- end }}

apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "esdb.fullname" . }}-gen-certs
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "esdb.labels" . | nindent 4 }}
    app.kubernetes.io/component: cluster
  annotations:
    "helm.sh/hook": post-install,post-upgrade
spec:
  ttlSecondsAfterFinished: 100
  backoffLimit: 2
  template:
    metadata:
      labels:
        {{- include "esdb.labels" . | nindent 8 }}
        app.kubernetes.io/component: cluster
    spec:
      serviceAccountName: {{ include "esdb.serviceAccountName" . }}
      initContainers:
        - name: gen-esdb-certs
          image: {{.Values.cliImages.genCerts.repository}}:{{.Values.cliImages.genCerts.tag}}
          imagePullPolicy: {{.Values.cliImages.genCerts.pullPolicy}}
          volumeMounts:
            - mountPath: /certs
              name: certs
          command:
            - /bin/sh
            - '-c'
            - |
              es-gencert-cli create-ca -days '{{.Values.certificatesLength.ca }}' -out /certs/ca
              chmod 444 /certs/ca/*
              {{range $i, $e := until (.Values.deployment.clusterSize | int) }}
              es-gencert-cli create-node -days '{{ $.Values.certificatesLength.node}}' \
                -ca-certificate /certs/ca/ca.crt -ca-key /certs/ca/ca.key \
                -dns-names 'localhost,{{ include "esdb.fullname" $ }}-cluster-{{$i}}' \
                -out /certs/{{$i}}
              chmod 444 /certs/{{$i}}/*
              {{end}}
      containers:
        - name: create-certs
          image: {{.Values.cliImages.kubectl.repository}}:{{.Values.cliImages.kubectl.tag}}
          imagePullPolicy: {{.Values.cliImages.kubectl.pullPolicy}}
          volumeMounts:
            - mountPath: /certs
              name: certs
          #Writing all of this in the yaml file isn't an elegant solution
          #But it works and doesn't necessitate any extra images
          command:
            - /bin/bash
            - '-c'
            - |
              #Start by patching esdb certs
              #Args are $1=key $2=filename
              values='{}'
              patch() {
                #Append key/value to values
                values=$(jq -c --arg k "$1" --arg v "$(base64 -w 0 $2)" '. += { ($k): $v }' <<<"$values")
              }
              patch ca.crt /certs/ca/ca.crt
              patch ca.key /certs/ca/ca.key
              {{- range $i, $e := until (.Values.deployment.clusterSize | int) }}
              patch node-{{$i}}.crt /certs/{{$i}}/node.crt
              patch node-{{$i}}.key /certs/{{$i}}/node.key
              {{- end}}

              #Build final patch json
              json=$(jq --argjson v "$values" '.[0] |= { "op": "replace", "path": "/data", "value": $v }'<<<'[]')
              kubectl patch secret -n '{{ .Release.Namespace }}' '{{ include "esdb.fullname" . }}-certs' --type=json "-p=$json"
              
              echo "Patched secret {{ include "esdb.fullname" . }}-certs"
              #Restart rollout (now that the certificates are available)
              kubectl rollout restart statefulset.apps -n '{{ .Release.Namespace }}' '{{ include "esdb.fullname" . }}-cluster'
              
      restartPolicy: Never
      volumes:
        - name: certs
          emptyDir: {}